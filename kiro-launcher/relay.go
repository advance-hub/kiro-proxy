package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// ── Relay Key Generation ──

// deriveRelayKey 从任意长度的 secret 派生 32 字节 AES key
// 与 Rust 端 relay::crypto::derive_key 保持一致
func deriveRelayKey(secret string) []byte {
	h := sha256.New()
	h.Write([]byte("kiro-relay-v1:"))
	h.Write([]byte(secret))
	return h.Sum(nil)
}

// GenerateRelayKey 将当前凭证加密为 relay API Key
// secret: 与服务器端 config.json 中 relaySecret 相同的共享密钥
func (a *App) GenerateRelayKey(secret string) (string, error) {
	if strings.TrimSpace(secret) == "" {
		return "", fmt.Errorf("请输入共享密钥")
	}

	dir, err := getDataDir()
	if err != nil {
		return "", err
	}
	credsPath := filepath.Join(dir, "credentials.json")

	cf, err := readFirstCredential(credsPath)
	if err != nil {
		return "", fmt.Errorf("读取凭据失败: %v", err)
	}

	// 先刷新 token
	refreshed, err := refreshCredentials(cf)
	if err != nil {
		return "", fmt.Errorf("Token 刷新失败: %v", err)
	}
	saveCredentialsFileSmart(refreshed)

	// 序列化为 JSON（与 Rust 端 KiroCredentials 结构一致）
	jsonData, err := json.Marshal(refreshed)
	if err != nil {
		return "", fmt.Errorf("序列化凭据失败: %v", err)
	}

	// AES-256-GCM 加密
	key := deriveRelayKey(secret)
	block, err := aes.NewCipher(key)
	if err != nil {
		return "", fmt.Errorf("创建加密器失败: %v", err)
	}
	gcm, err := cipher.NewGCM(block)
	if err != nil {
		return "", fmt.Errorf("创建 GCM 失败: %v", err)
	}

	nonce := make([]byte, gcm.NonceSize()) // 12 bytes
	if _, err := rand.Read(nonce); err != nil {
		return "", fmt.Errorf("生成随机数失败: %v", err)
	}

	// Seal: nonce 不作为 prefix（我们手动拼接）
	ciphertext := gcm.Seal(nil, nonce, jsonData, nil)

	// 拼接: nonce || ciphertext (包含 tag)
	payload := make([]byte, 0, len(nonce)+len(ciphertext))
	payload = append(payload, nonce...)
	payload = append(payload, ciphertext...)

	// base64url 编码（无 padding，与 Rust 端 URL_SAFE_NO_PAD 一致）
	encoded := base64.RawURLEncoding.EncodeToString(payload)

	return "relay-" + encoded, nil
}

// GenerateCredsKey 将当前凭证编码为 creds API Key（无加密，仅 base64）
// 适用于 HTTPS 部署场景，客户端凭证通过 base64 编码后作为 API Key 传递
func (a *App) GenerateCredsKey() (string, error) {
	dir, err := getDataDir()
	if err != nil {
		return "", err
	}
	credsPath := filepath.Join(dir, "credentials.json")

	cf, err := readFirstCredential(credsPath)
	if err != nil {
		return "", fmt.Errorf("读取凭据失败: %v", err)
	}

	// 先刷新 token
	refreshed, err := refreshCredentials(cf)
	if err != nil {
		return "", fmt.Errorf("Token 刷新失败: %v", err)
	}
	saveCredentialsFileSmart(refreshed)

	// 序列化为 JSON
	jsonData, err := json.Marshal(refreshed)
	if err != nil {
		return "", fmt.Errorf("序列化凭据失败: %v", err)
	}

	// base64url 编码（无 padding，与 Rust 端 URL_SAFE_NO_PAD 一致）
	encoded := base64.RawURLEncoding.EncodeToString(jsonData)

	return "creds-" + encoded, nil
}

// GenerateCredsKeyFromKeychain 从 Keychain 读取凭证并生成 creds key
func (a *App) GenerateCredsKeyFromKeychain() (string, error) {
	// 先尝试从 keychain 读取并写入文件
	kc, err := readKiroCredentials()
	if err != nil {
		return "", fmt.Errorf("从 Keychain 读取凭据失败: %v", err)
	}
	if err := writeKeychainCredentials(kc); err != nil {
		return "", fmt.Errorf("写入凭据失败: %v", err)
	}

	// 然后调用 GenerateCredsKey
	return a.GenerateCredsKey()
}

// GenerateRelayKeyFromKeychain 从 Keychain 读取凭证并生成 relay key
func (a *App) GenerateRelayKeyFromKeychain(secret string) (string, error) {
	if strings.TrimSpace(secret) == "" {
		return "", fmt.Errorf("请输入共享密钥")
	}

	// 先尝试从 keychain 读取并写入文件
	kc, err := readKiroCredentials()
	if err != nil {
		return "", fmt.Errorf("从 Keychain 读取凭据失败: %v", err)
	}
	if err := writeKeychainCredentials(kc); err != nil {
		return "", fmt.Errorf("写入凭据失败: %v", err)
	}

	// 然后调用 GenerateRelayKey
	return a.GenerateRelayKey(secret)
}

// ExportCredsToShellRC 导出 creds key 到 shell rc 文件
// 自动检测当前 shell 类型并更新对应的 rc 文件
func (a *App) ExportCredsToShellRC(baseURL string) error {
	// 生成 creds key
	credsKey, err := a.GenerateCredsKey()
	if err != nil {
		return fmt.Errorf("生成 creds key 失败: %v", err)
	}

	// 检测当前 shell
	shell := os.Getenv("SHELL")
	var rcFile string
	homeDir, err := os.UserHomeDir()
	if err != nil {
		return fmt.Errorf("获取用户目录失败: %v", err)
	}

	if strings.Contains(shell, "zsh") {
		rcFile = filepath.Join(homeDir, ".zshrc")
	} else if strings.Contains(shell, "bash") {
		rcFile = filepath.Join(homeDir, ".bashrc")
	} else {
		// 默认使用 .zshrc
		rcFile = filepath.Join(homeDir, ".zshrc")
	}

	// 读取现有内容
	content, err := os.ReadFile(rcFile)
	if err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("读取 %s 失败: %v", rcFile, err)
	}

	// 准备要写入的环境变量
	if baseURL == "" {
		baseURL = "http://127.0.0.1:8080/v1"
	}
	exportLines := fmt.Sprintf(`
# Kiro Proxy Environment Variables (Auto-generated by kiro-launcher)
export KIRO_API_KEY="%s"
export KIRO_BASE_URL="%s"
`, credsKey, baseURL)

	// 检查是否已存在 Kiro 配置
	contentStr := string(content)
	if strings.Contains(contentStr, "# Kiro Proxy Environment Variables") {
		// 替换现有配置
		lines := strings.Split(contentStr, "\n")
		var newLines []string
		skipping := false
		for _, line := range lines {
			if strings.Contains(line, "# Kiro Proxy Environment Variables") {
				skipping = true
				continue
			}
			if skipping {
				if strings.HasPrefix(line, "export KIRO_") {
					continue
				}
				if strings.TrimSpace(line) == "" {
					skipping = false
					continue
				}
			}
			newLines = append(newLines, line)
		}
		contentStr = strings.Join(newLines, "\n")
	}

	// 追加新配置
	contentStr = strings.TrimRight(contentStr, "\n") + exportLines

	// 写回文件
	if err := os.WriteFile(rcFile, []byte(contentStr), 0644); err != nil {
		return fmt.Errorf("写入 %s 失败: %v", rcFile, err)
	}

	return nil
}

// ── File Save Dialog ──

func (a *App) SaveAccountsToFile(filePath, content string) error {
	return os.WriteFile(filePath, []byte(content), 0644)
}
